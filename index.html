<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Not a Label - AI Music Terminal</title>
  
  <!-- PWA Meta Tags -->
  <meta name="description" content="AI-powered music creation terminal. Create, share, and collaborate through natural language commands.">
  <meta name="theme-color" content="#00ff00">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Not a Label Terminal">
  
  <!-- PWA Manifest -->
  <link rel="manifest" href="/manifest.json">
  
  <style>
    * { 
      margin: 0; 
      padding: 0; 
      box-sizing: border-box;
    }
    
    body { 
      background: #000; 
      color: #00ff00; 
      font-family: 'Courier New', 'Monaco', 'Menlo', monospace;
      overflow: hidden;
      height: 100vh;
      position: fixed;
      width: 100%;
    }
    
    .terminal {
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    
    .terminal-header {
      background: linear-gradient(135deg, #111, #001100);
      border-bottom: 1px solid #00ff0055;
      padding: 8px 15px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      min-height: 45px;
      flex-shrink: 0;
    }
    
    .terminal-title {
      display: flex;
      align-items: center;
      gap: 8px;
      color: #00ff00;
      font-size: 14px;
      font-weight: bold;
    }
    
    .terminal-content {
      flex: 1;
      overflow-y: auto;
      padding: 15px;
      scroll-behavior: smooth;
    }
    
    .terminal-line {
      margin: 2px 0;
      line-height: 1.4;
      font-size: 13px;
      word-wrap: break-word;
      white-space: pre-wrap;
    }
    
    .system-line { color: #00ffff; }
    .error-line { color: #ff0066; font-weight: bold; }
    .input-line { color: #00ff00; font-weight: bold; }
    .output-line { color: #cccccc; }
    .success-line { color: #00ff88; font-weight: bold; }
    .info-line { color: #ffaa00; }
    .highlight-line { 
      color: #00ff00; 
      background: rgba(0, 255, 0, 0.1);
      padding: 4px 8px;
      border-left: 3px solid #00ff00;
      margin: 4px 0;
      border-radius: 0 4px 4px 0;
    }
    
    .terminal-input-container {
      background: linear-gradient(135deg, #111, #001100);
      border-top: 1px solid #00ff0055;
      padding: 12px 15px;
      display: flex;
      align-items: center;
      gap: 10px;
      flex-shrink: 0;
    }
    
    .terminal-prompt {
      color: #00ff00;
      font-weight: bold;
      white-space: nowrap;
      user-select: none;
      min-width: fit-content;
    }
    
    .terminal-input {
      background: transparent;
      border: none;
      color: #00ff00;
      font-family: inherit;
      font-size: 13px;
      outline: none;
      padding: 6px 0;
      width: 100%;
      flex: 1;
    }
    
    .terminal-input::placeholder {
      color: #00ff0055;
      font-style: italic;
    }
    
    /* Community table styling */
    .terminal-line table {
      color: #00ff00;
      border-collapse: collapse;
      width: 100%;
      font-family: 'Courier New', monospace;
      font-size: 12px;
    }
    
    .terminal-line table th {
      color: #00ffff;
      border-bottom: 1px solid #00ff0055;
      text-align: left;
      padding: 6px;
      font-weight: bold;
    }
    
    .terminal-line table td {
      border-bottom: 1px solid #00ff0022;
      padding: 6px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    
    .terminal-line table tr:hover {
      background-color: rgba(0, 255, 0, 0.05);
    }
    
    .dim-line {
      color: #666;
      font-style: italic;
    }
  </style>
</head>
<body>
  <div class="terminal">
    <div class="terminal-header">
      <div class="terminal-title">
        <span>ğŸµ NOT A LABEL TERMINAL</span>
      </div>
    </div>
    
    <div class="terminal-content" id="terminalContent">
      <div class="terminal-line system-line">[SYSTEM] âœ… AI Music Generation Engine Active</div>
      <div class="terminal-line system-line">[SYSTEM] âœ… Community System Online</div>
      <div class="terminal-line system-line">[SYSTEM] âœ… Pattern Sharing Enabled</div>
      <div class="terminal-line system-line"></div>
      <div class="terminal-line highlight-line">ğŸµ Welcome to Not a Label - Where Music Meets AI</div>
      <div class="terminal-line output-line">Create, share, and discover music through natural language.</div>
      <div class="terminal-line output-line"></div>
      <div class="terminal-line success-line">âœ¨ NEW: Create your musical identity - no boring signups!</div>
      <div class="terminal-line info-line">ğŸ¯ Quick Start: "create trap beat" or "create musical identity"</div>
      <div class="terminal-line dim-line">ğŸ’¡ Type "help" to see all features</div>
      <div class="terminal-line system-line"></div>
    </div>
    
    <div class="terminal-input-container">
      <span class="terminal-prompt" id="terminalPrompt">nal@music:~$</span>
      <input type="text" class="terminal-input" id="terminalInput" 
             placeholder="Type any command and press Enter..." 
             autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
    </div>
  </div>

  <!-- Simple Web Audio for immediate sound feedback -->
  <script>
    // Initialize simple audio system that always works
    window.audioReady = false;
    window.audioContext = null;
    
    function initSimpleAudio() {
      try {
        window.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        window.audioReady = true;
        console.log('âœ… Simple audio system ready');
        
        // Test sound on first click
        if (window.addLine) {
          window.addLine('ğŸ”Š Audio system ready - click PLAY to hear patterns!', 'success-line');
        }
      } catch (err) {
        console.error('Audio initialization failed:', err);
      }
    }
    
    // Initialize audio on first user interaction
    document.addEventListener('click', function initAudioOnClick() {
      if (!window.audioReady) {
        initSimpleAudio();
        document.removeEventListener('click', initAudioOnClick);
      }
    }, { once: true });
  </script>
  
  <!-- Load AI Components -->
  <script src="/js/ai-integration.js?v=1749313000"></script>
  <script src="/js/nlp.js?v=1749313000"></script>
  <script src="/js/enhanced-pattern-generator.js?v=1749313000"></script>
  <script src="/js/musical-identity-creator.js?v=1749313000"></script>
  <script src="/js/community.js?v=1749313000"></script>
  <script src="/js/pattern-sharing.js?v=1749313000"></script>
  
  <!-- Phase 1 Procedural AI System (Client-side) -->
  <script src="/js/semantic-analysis-engine.js?v=2000000000"></script>
  <script src="/js/procedural-pattern-generator.js?v=2000000000"></script>
  <script src="/js/uniqueness-engine.js?v=2000000000"></script>
  
  <!-- Phase 2 Advanced AI System -->
  <script src="/js/pattern-dna-engine.js?v=2100000000"></script>
  <script src="/js/context-aware-engine.js?v=2100000000"></script>
  <script src="/js/advanced-personalization-engine.js?v=2100000000"></script>
  <script src="/js/phase2-integration-engine.js?v=2100000000"></script>
  
  <!-- Phase 3 AI Ensemble System -->
  <script src="/js/specialized-ai-agents.js?v=3000000000"></script>
  <script src="/js/ai-ensemble-conductor.js?v=3000000000"></script>
  <script src="/js/phase3-integration-engine.js?v=3000000000"></script>
  
  <!-- Advanced Pattern Evolution System -->
  <script src="/js/pattern-evolution-engine.js?v=3100000000"></script>
  <script src="/js/dna-mutation-system.js?v=3100000000"></script>
  <script src="/js/cross-pattern-breeding.js?v=3100000000"></script>
  
  <script>
    console.log('ğŸš€ Not a Label Terminal loading v3.1.0 - Phase 3 AI Ensemble + Pattern Evolution...');
    
    // Initialize AI components
    let nalaAI, nlp, patternGenerator, musicalIdentityCreator, communitySystem, patternSharingSystem;
    let currentPattern = null;
    let audioContext = null;
    let currentUser = null;
    
    // Evolution system components
    let evolutionEngine, mutationSystem, breedingSystem;
    let patternLibrary = [];
    
    function addLine(text, className = 'output-line') {
      const line = document.createElement('div');
      line.className = `terminal-line ${className}`;
      line.textContent = text;
      document.getElementById('terminalContent').appendChild(line);
      
      setTimeout(() => {
        const content = document.getElementById('terminalContent');
        content.scrollTop = content.scrollHeight;
      }, 10);
    }
    
    function addHTML(html, className = 'output-line') {
      const line = document.createElement('div');
      line.className = `terminal-line ${className}`;
      line.innerHTML = html;
      document.getElementById('terminalContent').appendChild(line);
      
      setTimeout(() => {
        const content = document.getElementById('terminalContent');
        content.scrollTop = content.scrollHeight;
      }, 10);
    }
    
    async function generateMusic(command) {
      try {
        addLine('ğŸ¤– Nala AI (DeepSeek R1) analyzing your request...', 'info-line');
        
        // Process with NLP for context
        const nlpResult = nlp.processCommand(command);
        console.log('NLP Result:', nlpResult);
        
        if (nlpResult.type === 'create_music') {
          addLine(`ğŸµ AI generating ${nlpResult.genre} music...`, 'success-line');
          
          // Use Nala AI (DeepSeek R1) for generation
          const musicDNA = {
            primaryGenre: nlpResult.genre,
            preferredMood: nlpResult.mood,
            energyLevel: Math.round((nlpResult.tempo || 120) / 20),
            complexity: 5
          };
          
          const context = {
            timeOfDay: getTimeOfDay(),
            activity: extractActivity(command),
            userAgent: navigator.userAgent
          };
          
          console.log('ğŸ¤– Calling Enhanced Nala AI API with:', { command, musicDNA, context });
          
          let result;
          
          try {
            // Try backend API first (with Phase 3 support)
            const response = await fetch('/api/generate-music', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                userInput: command,
                musicDNA: musicDNA,
                context: context,
                requestPhase: 3 // Request Phase 3 if available
              })
            });
            
            if (response.ok) {
              result = await response.json();
              console.log('ğŸ¤– Backend result:', result);
            } else {
              throw new Error(`API error: ${response.status}`);
            }
          } catch (apiError) {
            console.log('ğŸ”„ Backend unavailable, using client-side AI systems');
            
            // Try Phase 3 AI Ensemble System first
            console.log('ğŸ” Checking Phase 3 in generateMusic:', {
              Phase3IntegrationEngine: !!window.Phase3IntegrationEngine,
              AIEnsembleConductor: !!window.AIEnsembleConductor,
              RhythmistAI: !!window.RhythmistAI,
              MelodistAI: !!window.MelodistAI,
              HarmonistAI: !!window.HarmonistAI
            });
            
            if (window.Phase3IntegrationEngine && window.AIEnsembleConductor) {
              console.log('ğŸ¼ Using Phase 3 AI Ensemble System');
              addLine('ğŸ¼ Activating Phase 3: AI Ensemble Collaboration...', 'success-line');
              
              const phase3Engine = new Phase3IntegrationEngine();
              const phase3Context = {
                musicDNA: musicDNA,
                userContext: context,
                sessionData: { interactions: 1 },
                timeConstraints: 'realtime'
              };
              
              const phase3Result = await phase3Engine.generateEnsemblePattern(command, phase3Context);
              
              result = {
                success: true,
                code: phase3Result.code,
                description: phase3Result.description,
                metadata: phase3Result.metadata
              };
              console.log('ğŸ¼ Phase 3 AI Ensemble result:', result);
              
            } else if (window.Phase2IntegrationEngine && window.PatternDNAEngine && window.ContextAwareEngine && window.AdvancedPersonalizationEngine) {
              // Fallback to Phase 2 Advanced AI System
              console.log('ğŸ”„ Phase 3 unavailable, using Phase 2 Advanced AI System');
              addLine('ğŸ§¬ Activating Phase 2: Multi-dimensional Pattern DNA...', 'success-line');
              
              const phase2Engine = new Phase2IntegrationEngine();
              const phase2Context = {
                musicDNA: musicDNA,
                userContext: context,
                sessionData: { interactions: 1 }
              };
              
              const phase2Result = await phase2Engine.generateAdvancedPattern(command, phase2Context);
              
              result = {
                success: true,
                code: phase2Result.code,
                description: phase2Result.description,
                metadata: phase2Result.metadata
              };
              console.log('ğŸš€ Phase 2 Advanced result:', result);
              
            } else if (window.ProceduralPatternGenerator && window.SemanticAnalysisEngine && window.UniquenessEngine) {
              // Fallback to Phase 1 Procedural System
              console.log('ğŸ”„ Advanced AI unavailable, using Phase 1 Procedural System');
              addLine('ğŸ¤– Using Phase 1 Procedural AI...', 'info-line');
              
              const proceduralGenerator = new ProceduralPatternGenerator();
              const uniquenessEngine = new UniquenessEngine();
              
              const patternResult = proceduralGenerator.generatePattern(command);
              const uniqueResult = await uniquenessEngine.ensureUniqueness(patternResult, patternResult.analysis);
              
              result = {
                success: true,
                code: uniqueResult.code,
                description: uniqueResult.description + ' (Generated by Phase 1 Procedural System - Client-side)',
                metadata: {
                  ...uniqueResult.metadata,
                  timestamp: new Date().toISOString(),
                  source: 'phase1_client',
                  uniqueness: uniqueResult.analysis ? uniqueResult.analysis.uniqueness : 1.0,
                  semantic_analysis: uniqueResult.analysis
                }
              };
              console.log('ğŸ¤– Client-side Phase 1 result:', result);
            } else {
              // Fallback to enhanced pattern generator
              console.log('ğŸ”„ Advanced AI components not loaded, using enhanced fallback');
              result = patternGenerator.generatePattern(command, musicDNA);
              result.description += ' (Enhanced Fallback System)';
            }
          }
          
          currentPattern = result;
          
          addLine('', 'output-line');
          addLine('ğŸ¼ STRUDEL PATTERN GENERATED:', 'success-line');
          addLine('', 'output-line');
          
          // Display the Strudel code with syntax highlighting
          const codeDisplay = document.createElement('div');
          codeDisplay.className = 'terminal-line';
          codeDisplay.style.cssText = `
            background: rgba(0, 255, 0, 0.05);
            border: 1px solid #00ff0033;
            border-radius: 4px;
            padding: 12px;
            margin: 8px 0;
            font-family: 'Courier New', monospace;
            color: #00ff88;
            overflow-x: auto;
            white-space: pre;
          `;
          codeDisplay.textContent = result.code;
          document.getElementById('terminalContent').appendChild(codeDisplay);
          
          addLine('', 'output-line');
          addLine(`ğŸ“ ${result.description}`, 'info-line');
          
          // Share with jam room if connected
          if (window.jamUI && window.jamUI.jam && window.jamUI.jam.isInRoom()) {
            window.jamUI.sharePattern(result.code);
            addLine('ğŸ¸ Pattern shared with jam room!', 'success-line');
          }
          
          // Add to breeding pool
          if (window.breedingUI) {
            window.breedingUI.capturePattern(result.code, result.description);
          }
          
          addLine('', 'output-line');
          
          // Add playback controls with unique IDs
          const patternId = `pattern_${Date.now()}`;
          const controlsHTML = `
            <div style="display: flex; gap: 10px; align-items: center; margin: 10px 0;">
              <button id="playBtn_${patternId}" style="background: #00ff00; color: #000; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-weight: bold;">
                â–¶ï¸ PLAY
              </button>
              <button id="stopBtn_${patternId}" style="background: #ff0066; color: #fff; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-weight: bold;">
                â¹ï¸ STOP
              </button>
              <button id="saveBtn_${patternId}" style="background: #0066ff; color: #fff; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-weight: bold;">
                ğŸ’¾ SAVE
              </button>
            </div>
          `;
          addHTML(controlsHTML);
          
          // Add event listeners for controls with unique IDs
          setTimeout(() => {
            const playBtn = document.getElementById(`playBtn_${patternId}`);
            const stopBtn = document.getElementById(`stopBtn_${patternId}`);
            const saveBtn = document.getElementById(`saveBtn_${patternId}`);
            
            console.log('ğŸ›ï¸ Adding event listeners for pattern:', patternId);
            
            if (playBtn) {
              playBtn.addEventListener('click', () => {
                console.log('ğŸµ Play button clicked for pattern:', patternId);
                playPattern(result.code);
              });
              console.log('âœ… Play button listener added');
            } else {
              console.error('âŒ Play button not found:', `playBtn_${patternId}`);
            }
            
            if (stopBtn) {
              stopBtn.addEventListener('click', stopPattern);
              console.log('âœ… Stop button listener added');
            }
            
            if (saveBtn) {
              saveBtn.addEventListener('click', () => savePattern(result));
              console.log('âœ… Save button listener added');
            }
          }, 100);
          
          addLine('ğŸ¯ Pattern ready! Use controls above to play, stop, or save.', 'success-line');
          
        } else if (nlpResult.type === 'sentiment') {
          addLine(nlpResult.response, 'success-line');
        } else {
          addLine(`ğŸ¤” ${nlpResult.response || "I can help you create music! Try: 'create trap beat' or 'make lo-fi music'"}`, 'info-line');
        }
        
      } catch (error) {
        console.error('Music generation error:', error);
        addLine('âŒ Error generating music. Please try again.', 'error-line');
      }
    }
    
    let currentPlayback = null;
    
    function playPattern(strudelCode) {
      console.log('ğŸµ playPattern called with:', strudelCode);
      addLine('ğŸ”Š Playing pattern audio preview...', 'info-line');
      
      // Initialize audio if not ready
      if (!window.audioReady) {
        if (!window.audioContext) {
          try {
            console.log('ğŸµ Creating audio context...');
            window.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            window.audioReady = true;
            console.log('ğŸµ Audio context created:', window.audioContext.state);
          } catch (err) {
            console.error('ğŸµ Audio context creation failed:', err);
            addLine('âŒ Audio not available in this browser', 'error-line');
            return;
          }
        } else {
          console.log('ğŸµ Audio context already exists:', window.audioContext.state);
        }
      }
      
      // Stop any current playback
      if (currentPlayback) {
        clearTimeout(currentPlayback);
      }
      
      // Extract notes from the pattern
      const noteMatches = strudelCode.match(/note\("([^"]+)"\)/g) || [];
      let notes = ['c4', 'e4', 'g4', 'c5']; // Default melody
      
      if (noteMatches.length > 0) {
        const noteString = noteMatches[0].match(/note\("([^"]+)"\)/)[1];
        notes = noteString.split(' ').filter(n => n !== '~' && n.length > 0);
      }
      
      // Determine genre for drum pattern
      const isDrums = strudelCode.includes('sound("bd') || strudelCode.includes('sound("hh') || strudelCode.includes('sound("sd');
      
      // Play the pattern
      try {
        console.log('ğŸµ Starting audio playback - isDrums:', isDrums, 'notes:', notes);
        if (isDrums) {
          playDrumPattern(strudelCode, notes);
        } else {
          playMelodyPattern(notes);
        }
        console.log('ğŸµ Audio playback started successfully');
        addLine('ğŸµ Audio preview playing! (4 beats)', 'success-line');
      } catch (err) {
        console.error('Playback error:', err);
        addLine('ğŸµ Generated pattern code (audio preview unavailable)', 'info-line');
      }
    }
    
    function playDrumPattern(strudelCode, melodyNotes) {
      const ctx = window.audioContext;
      console.log('ğŸ¥ playDrumPattern - audioContext state:', ctx.state);
      
      // Create master gain node for visualization
      if (!window.masterGain) {
        window.masterGain = ctx.createGain();
        window.masterGain.connect(ctx.destination);
      }
      
      // Connect visualizer if active
      if (window.visualizer && window.visualizer.isActive) {
        window.visualizer.connectToAudioContext(ctx, window.masterGain);
      }
      
      // Resume audio context if suspended
      if (ctx.state === 'suspended') {
        console.log('ğŸµ Resuming suspended audio context...');
        ctx.resume().then(() => {
          console.log('ğŸµ Audio context resumed, starting drums');
          playDrumPatternInternal(ctx, strudelCode, melodyNotes);
        });
        return;
      }
      
      playDrumPatternInternal(ctx, strudelCode, melodyNotes);
    }
    
    function playDrumPatternInternal(ctx, strudelCode, melodyNotes) {
      const time = ctx.currentTime;
      
      // Create drum sounds using noise and oscillators
      const beatTimes = [0, 0.5, 1.0, 1.5]; // 4 beats
      
      beatTimes.forEach((beatTime, i) => {
        // Kick drum (low frequency)
        if (strudelCode.includes('bd') && (i === 0 || i === 2)) {
          const kickOsc = ctx.createOscillator();
          const kickGain = ctx.createGain();
          
          kickOsc.frequency.value = 60;
          kickOsc.type = 'sine';
          kickGain.gain.value = 0.3;
          
          kickOsc.connect(kickGain);
          kickGain.connect(window.masterGain || ctx.destination);
          
          kickOsc.start(time + beatTime);
          kickGain.gain.exponentialRampToValueAtTime(0.001, time + beatTime + 0.1);
          kickOsc.stop(time + beatTime + 0.1);
        }
        
        // Snare drum (noise burst)
        if (strudelCode.includes('sd') && (i === 1 || i === 3)) {
          const noiseBuffer = ctx.createBuffer(1, ctx.sampleRate * 0.1, ctx.sampleRate);
          const noiseData = noiseBuffer.getChannelData(0);
          for (let j = 0; j < noiseData.length; j++) {
            noiseData[j] = Math.random() * 2 - 1;
          }
          
          const noiseSource = ctx.createBufferSource();
          const noiseGain = ctx.createGain();
          const noiseFilter = ctx.createBiquadFilter();
          
          noiseSource.buffer = noiseBuffer;
          noiseFilter.frequency.value = 1000;
          noiseGain.gain.value = 0.2;
          
          noiseSource.connect(noiseFilter);
          noiseFilter.connect(noiseGain);
          noiseGain.connect(window.masterGain || ctx.destination);
          
          noiseSource.start(time + beatTime);
          noiseGain.gain.exponentialRampToValueAtTime(0.001, time + beatTime + 0.05);
        }
        
        // Hi-hat (high frequency noise)
        if (strudelCode.includes('hh')) {
          const hhOsc = ctx.createOscillator();
          const hhGain = ctx.createGain();
          const hhFilter = ctx.createBiquadFilter();
          
          hhOsc.frequency.value = 8000;
          hhOsc.type = 'square';
          hhFilter.frequency.value = 10000;
          hhGain.gain.value = 0.1;
          
          hhOsc.connect(hhFilter);
          hhFilter.connect(hhGain);
          hhGain.connect(window.masterGain || ctx.destination);
          
          hhOsc.start(time + beatTime);
          hhGain.gain.exponentialRampToValueAtTime(0.001, time + beatTime + 0.02);
          hhOsc.stop(time + beatTime + 0.02);
        }
      });
      
      // Add melody on top if available
      if (melodyNotes.length > 0) {
        setTimeout(() => playMelodyPattern(melodyNotes), 100);
      }
    }
    
    function playMelodyPattern(notes) {
      const ctx = window.audioContext;
      console.log('ğŸ¹ playMelodyPattern - audioContext state:', ctx.state);
      
      // Resume audio context if suspended
      if (ctx.state === 'suspended') {
        console.log('ğŸµ Resuming suspended audio context...');
        ctx.resume().then(() => {
          console.log('ğŸµ Audio context resumed, starting melody');
          playMelodyPatternInternal(ctx, notes);
        });
        return;
      }
      
      playMelodyPatternInternal(ctx, notes);
    }
    
    function playMelodyPatternInternal(ctx, notes) {
      let time = ctx.currentTime;
      
      const noteFrequencies = {
        'c1': 32.70, 'c2': 65.41, 'c3': 130.81, 'c4': 261.63, 'c5': 523.25,
        'd1': 36.71, 'd2': 73.42, 'd3': 146.83, 'd4': 293.66, 'd5': 587.33,
        'e1': 41.20, 'e2': 82.41, 'e3': 164.81, 'e4': 329.63, 'e5': 659.25,
        'f1': 43.65, 'f2': 87.31, 'f3': 174.61, 'f4': 349.23, 'f5': 698.46,
        'g1': 49.00, 'g2': 98.00, 'g3': 196.00, 'g4': 392.00, 'g5': 783.99,
        'a1': 55.00, 'a2': 110.00, 'a3': 220.00, 'a4': 440.00, 'a5': 880.00,
        'b1': 61.74, 'b2': 123.47, 'b3': 246.94, 'b4': 493.88, 'b5': 987.77
      };
      
      notes.slice(0, 4).forEach((note, i) => {
        if (note && note !== '~') {
          const freq = noteFrequencies[note.toLowerCase()] || 261.63;
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          
          osc.frequency.value = freq;
          osc.type = 'sine';
          gain.gain.value = 0.15;
          
          osc.connect(gain);
          gain.connect(window.masterGain || ctx.destination);
          
          const noteTime = time + i * 0.4;
          osc.start(noteTime);
          gain.gain.exponentialRampToValueAtTime(0.001, noteTime + 0.3);
          osc.stop(noteTime + 0.3);
        }
      });
    }
    
    function stopPattern() {
      try {
        console.log('â¹ï¸ stopPattern called');
        if (currentPlayback) {
          clearTimeout(currentPlayback);
          currentPlayback = null;
        }
        
        // Create a new audio context for next playback instead of suspending/resuming
        if (window.audioContext) {
          console.log('ğŸµ Current audio context state:', window.audioContext.state);
          // Don't suspend - just let current sounds finish naturally
          // Create fresh audio context for reliable next playback
          try {
            window.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            console.log('ğŸµ Created fresh audio context for next playback');
          } catch (err) {
            console.warn('ğŸµ Could not create fresh audio context:', err);
          }
        }
        
        addLine('â¹ï¸ Audio stopped.', 'success-line');
      } catch (error) {
        console.error('Stop error:', error);
        addLine('â¹ï¸ Playback stopped.', 'info-line');
      }
    }
    
    function savePattern(pattern) {
      if (patternSharingSystem) {
        patternSharingSystem.savePattern(pattern, `${pattern.metadata.genre}_${Date.now()}`);
      } else {
        addLine('ğŸ’¾ Pattern saved to your library!', 'success-line');
        addLine(`ğŸ“‚ Saved as: "${pattern.metadata.genre}_${Date.now()}"`, 'output-line');
      }
    }
    
    function getTimeOfDay() {
      const hour = new Date().getHours();
      if (hour < 6) return 'night';
      if (hour < 12) return 'morning';
      if (hour < 18) return 'afternoon';
      if (hour < 22) return 'evening';
      return 'night';
    }
    
    function extractActivity(command) {
      const cmd = command.toLowerCase();
      if (cmd.includes('study') || cmd.includes('focus')) return 'studying';
      if (cmd.includes('workout') || cmd.includes('gym') || cmd.includes('exercise')) return 'working out';
      if (cmd.includes('party') || cmd.includes('dance') || cmd.includes('club')) return 'socializing';
      if (cmd.includes('create') || cmd.includes('art') || cmd.includes('creative')) return 'creating';
      return 'default';
    }
    
    function showUserProfile(user) {
      addLine('', 'output-line');
      addLine('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success-line');
      addLine('ğŸµ YOUR MUSICAL PROFILE', 'highlight-line');
      addLine('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success-line');
      addLine('', 'output-line');
      
      addLine(`ğŸ¨ Artist Name: ${user.artistName}`, 'info-line');
      addLine(`ğŸ¼ Primary Genre: ${user.musicDNA?.primaryGenre || 'Not set'}`, 'output-line');
      addLine(`ğŸ­ Preferred Mood: ${user.musicDNA?.preferredMood || 'Not set'}`, 'output-line');
      addLine(`âš¡ Energy Level: ${user.musicDNA?.energyLevel || 'Not set'}/10`, 'output-line');
      addLine(`ğŸ§© Complexity: ${user.musicDNA?.complexity || 'Not set'}/10`, 'output-line');
      
      if (user.musicDNA?.keywords && user.musicDNA.keywords.length > 0) {
        addLine(`ğŸ·ï¸ Style Keywords: ${user.musicDNA.keywords.join(', ')}`, 'output-line');
      }
      
      if (user.signaturePattern) {
        addLine('', 'output-line');
        addLine('ğŸµ YOUR SIGNATURE PATTERN:', 'success-line');
        addLine(`ğŸ“ ${user.signaturePattern.description}`, 'info-line');
        
        const codeDisplay = document.createElement('div');
        codeDisplay.className = 'terminal-line';
        codeDisplay.style.cssText = `
          background: rgba(0, 255, 0, 0.05);
          border: 1px solid #00ff0033;
          border-radius: 4px;
          padding: 8px;
          margin: 8px 0;
          font-family: 'Courier New', monospace;
          color: #00ff88;
          overflow-x: auto;
          white-space: pre;
        `;
        codeDisplay.textContent = user.signaturePattern.strudelCode;
        document.getElementById('terminalContent').appendChild(codeDisplay);
      }
      
      addLine('', 'output-line');
      addLine('ğŸ’¡ Commands: "create new pattern", "update profile", "logout"', 'info-line');
    }
    
    function showAbout() {
      addLine('', 'output-line');
      addLine('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success-line');
      addLine('ğŸµ NOT A LABEL - ABOUT', 'highlight-line');
      addLine('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', 'success-line');
      addLine('', 'output-line');
      
      addLine('A revolutionary AI-powered music creation platform', 'info-line');
      addLine('where identity is created through creativity, not forms.', 'output-line');
      addLine('', 'output-line');
      
      addLine('âœ¨ FEATURES:', 'success-line');
      addLine('  â€¢ AI Music Generation from natural language', 'output-line');
      addLine('  â€¢ Musical Identity Creation (no boring signups!)', 'output-line');
      addLine('  â€¢ Community Discovery based on Musical DNA', 'output-line');
      addLine('  â€¢ Pattern Sharing, Remixing & Collaboration', 'output-line');
      addLine('  â€¢ Real-time Strudel pattern synthesis', 'output-line');
      addLine('', 'output-line');
      
      addLine('ğŸ§¬ TECHNOLOGY:', 'success-line');
      addLine('  â€¢ Custom NLP Engine for music understanding', 'output-line');
      addLine('  â€¢ Enhanced Pattern Generator with genre AI', 'output-line');
      addLine('  â€¢ Musical DNA matching algorithm', 'output-line');
      addLine('  â€¢ Strudel live coding integration', 'output-line');
      addLine('', 'output-line');
      
      addLine('ğŸŒ COMMUNITY:', 'success-line');
      addLine('  â€¢ 50+ simulated creators with unique profiles', 'output-line');
      addLine('  â€¢ Genre-based communities and tribes', 'output-line');
      addLine('  â€¢ Real-time pattern sharing and remixing', 'output-line');
      addLine('  â€¢ Collaborative music creation tools', 'output-line');
      addLine('', 'output-line');
      
      addLine('ğŸ’¡ Created with â¤ï¸ for musicians who think differently', 'highlight-line');
      addLine('ğŸ”— https://not-a-label.art', 'info-line');
      addLine('', 'output-line');
    }
    
    // Evolution command handlers
    async function handleEvolutionCommand(command) {
      if (!evolutionEngine) {
        addLine('âŒ Evolution engine not available', 'error-line');
        return;
      }
      
      if (!currentPattern) {
        addLine('âŒ No pattern to evolve. Create a pattern first!', 'error-line');
        return;
      }
      
      addLine('ğŸ§¬ Starting pattern evolution...', 'info-line');
      
      try {
        const generations = command.match(/(\d+)\s*generations?/i)?.[1] || 3;
        const strategy = command.includes('experimental') ? 'experimental' : 
                        command.includes('guided') ? 'guided' : 'natural';
        
        const evolvedPattern = await evolutionEngine.evolvePattern(currentPattern, {
          strategy: strategy,
          generations: parseInt(generations),
          targetFitness: 0.8
        });
        
        if (evolvedPattern.success) {
          currentPattern = evolvedPattern;
          patternLibrary.push(evolvedPattern);
          
          addLine('', 'output-line');
          addLine('ğŸ§¬ PATTERN EVOLUTION COMPLETE:', 'success-line');
          addLine(`ğŸ“Š Strategy: ${strategy}, Generations: ${generations}`, 'info-line');
          addLine(`ğŸ“ ${evolvedPattern.description}`, 'info-line');
          
          const codeDisplay = document.createElement('div');
          codeDisplay.className = 'terminal-line';
          codeDisplay.style.cssText = `
            background: rgba(0, 255, 0, 0.05);
            border: 1px solid #00ff0033;
            border-radius: 4px;
            padding: 12px;
            margin: 8px 0;
            font-family: 'Courier New', monospace;
            color: #00ff88;
            overflow-x: auto;
            white-space: pre;
          `;
          codeDisplay.textContent = evolvedPattern.code;
          document.getElementById('terminalContent').appendChild(codeDisplay);
          
          addLine('', 'output-line');
          addPlaybackControls(evolvedPattern);
        }
      } catch (error) {
        console.error('Evolution error:', error);
        addLine('âŒ Evolution failed: ' + error.message, 'error-line');
      }
    }
    
    async function handleMutationCommand(command) {
      if (!mutationSystem) {
        addLine('âŒ DNA mutation system not available', 'error-line');
        return;
      }
      
      if (!currentPattern) {
        addLine('âŒ No pattern to mutate. Create a pattern first!', 'error-line');
        return;
      }
      
      addLine('ğŸ§¬ Applying DNA mutations...', 'info-line');
      
      try {
        const intensity = command.match(/intensity\s+([0-9.]+)/i)?.[1] || 0.3;
        const mutationType = command.includes('experimental') ? 'random' : 'adaptive';
        
        const mutatedPattern = await mutationSystem.mutatePatternDNA(currentPattern, {
          mutationType: mutationType,
          intensity: parseFloat(intensity),
          preserveGenre: !command.includes('radical')
        });
        
        if (mutatedPattern.success) {
          currentPattern = mutatedPattern;
          patternLibrary.push(mutatedPattern);
          
          addLine('', 'output-line');
          addLine('ğŸ§¬ DNA MUTATION COMPLETE:', 'success-line');
          addLine(`ğŸ”¬ Mutation Type: ${mutatedPattern.metadata.mutationType}`, 'info-line');
          addLine(`ğŸ“ ${mutatedPattern.description}`, 'info-line');
          
          const codeDisplay = document.createElement('div');
          codeDisplay.className = 'terminal-line';
          codeDisplay.style.cssText = `
            background: rgba(0, 255, 0, 0.05);
            border: 1px solid #00ff0033;
            border-radius: 4px;
            padding: 12px;
            margin: 8px 0;
            font-family: 'Courier New', monospace;
            color: #00ff88;
            overflow-x: auto;
            white-space: pre;
          `;
          codeDisplay.textContent = mutatedPattern.code;
          document.getElementById('terminalContent').appendChild(codeDisplay);
          
          addLine('', 'output-line');
          addPlaybackControls(mutatedPattern);
        }
      } catch (error) {
        console.error('Mutation error:', error);
        addLine('âŒ Mutation failed: ' + error.message, 'error-line');
      }
    }
    
    async function handleBreedingCommand(command) {
      if (!breedingSystem) {
        addLine('âŒ Breeding system not available', 'error-line');
        return;
      }
      
      if (patternLibrary.length < 2) {
        addLine('âŒ Need at least 2 patterns in library to breed. Create more patterns!', 'error-line');
        addLine('ğŸ’¡ Try: "create trap beat", then "create jazz melody", then "breed patterns"', 'info-line');
        return;
      }
      
      addLine('ğŸ§¬ Starting pattern breeding...', 'info-line');
      
      try {
        const strategy = command.includes('experimental') ? 'polygamous' :
                        command.includes('chimeric') ? 'chimeric' : 'sexual';
        const offspring = command.match(/(\d+)\s*offspring/i)?.[1] || 1;
        
        // Select parents (last 2-4 patterns from library)
        const parentCount = Math.min(patternLibrary.length, strategy === 'polygamous' ? 4 : 2);
        const parents = patternLibrary.slice(-parentCount);
        
        const breedingResult = await breedingSystem.breedPatterns(parents, {
          strategy: strategy,
          offspring: parseInt(offspring),
          allowHybridization: true
        });
        
        if (breedingResult.length > 0) {
          const child = breedingResult[0];
          currentPattern = child;
          patternLibrary.push(child);
          
          addLine('', 'output-line');
          addLine('ğŸ§¬ PATTERN BREEDING COMPLETE:', 'success-line');
          addLine(`ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ Strategy: ${strategy}, Parents: ${parents.length}`, 'info-line');
          addLine(`ğŸ“ ${child.description}`, 'info-line');
          
          const codeDisplay = document.createElement('div');
          codeDisplay.className = 'terminal-line';
          codeDisplay.style.cssText = `
            background: rgba(0, 255, 0, 0.05);
            border: 1px solid #00ff0033;
            border-radius: 4px;
            padding: 12px;
            margin: 8px 0;
            font-family: 'Courier New', monospace;
            color: #00ff88;
            overflow-x: auto;
            white-space: pre;
          `;
          codeDisplay.textContent = child.code;
          document.getElementById('terminalContent').appendChild(codeDisplay);
          
          addLine('', 'output-line');
          addPlaybackControls(child);
        }
      } catch (error) {
        console.error('Breeding error:', error);
        addLine('âŒ Breeding failed: ' + error.message, 'error-line');
      }
    }
    
    function addPlaybackControls(pattern) {
      const patternId = `pattern_${Date.now()}`;
      const controlsHTML = `
        <div style="display: flex; gap: 10px; align-items: center; margin: 10px 0;">
          <button id="playBtn_${patternId}" style="background: #00ff00; color: #000; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-weight: bold;">
            â–¶ï¸ PLAY
          </button>
          <button id="stopBtn_${patternId}" style="background: #ff0066; color: #fff; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-weight: bold;">
            â¹ï¸ STOP
          </button>
          <button id="saveBtn_${patternId}" style="background: #0066ff; color: #fff; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-weight: bold;">
            ğŸ’¾ SAVE
          </button>
        </div>
      `;
      addHTML(controlsHTML);
      
      setTimeout(() => {
        const playBtn = document.getElementById(`playBtn_${patternId}`);
        const stopBtn = document.getElementById(`stopBtn_${patternId}`);
        const saveBtn = document.getElementById(`saveBtn_${patternId}`);
        
        if (playBtn) {
          playBtn.addEventListener('click', () => playPattern(pattern.code));
        }
        if (stopBtn) {
          stopBtn.addEventListener('click', stopPattern);
        }
        if (saveBtn) {
          saveBtn.addEventListener('click', () => savePattern(pattern));
        }
      }, 100);
    }
    
    async function executeCommand(command) {
      if (!command.trim()) return;
      
      // Display command
      addLine(`nal@music:~$ ${command}`, 'input-line');
      
      // Simple command processing
      const lowerCommand = command.toLowerCase();
      
      if (lowerCommand === 'clear') {
        document.getElementById('terminalContent').innerHTML = '';
        addLine('âœ… Terminal cleared.', 'system-line');
        return;
      }
      
      if (lowerCommand === 'help') {
        addLine('', 'output-line');
        addLine('ğŸµ NOT A LABEL TERMINAL COMMANDS:', 'success-line');
        addLine('', 'output-line');
        addLine('ğŸ¼ MUSIC GENERATION:', 'info-line');
        addLine('  create trap beat              - Generate trap music', 'output-line');
        addLine('  make lo-fi music for studying - Create chill beats', 'output-line');
        addLine('  generate drill pattern        - UK drill beats', 'output-line');
        addLine('  create aggressive trap        - High energy trap', 'output-line');
        addLine('  make something dreamy         - Atmospheric music', 'output-line');
        addLine('  create dark house music       - Dark electronic', 'output-line');
        addLine('', 'output-line');
        addLine('ğŸ¨ IDENTITY & PROFILE:', 'info-line');
        addLine('  create musical identity       - Start identity creation', 'output-line');
        addLine('  signup                        - Begin account creation', 'output-line');
        addLine('  login                         - Sign into existing account', 'output-line');
        addLine('  my profile                    - View your musical profile', 'output-line');
        addLine('', 'output-line');
        addLine('ğŸŒ COMMUNITY & DISCOVERY:', 'info-line');
        addLine('  community feed                - View recent activity', 'output-line');
        addLine('  find my tribe                 - Discover similar creators', 'output-line');
        addLine('  explore [genre]               - Browse genre communities', 'output-line');
        addLine('  trending patterns             - See popular creations', 'output-line');
        addLine('  genre stats                   - Community statistics', 'output-line');
        addLine('', 'output-line');
        addLine('ğŸµ PATTERN SHARING:', 'info-line');
        addLine('  browse patterns               - Explore shared patterns', 'output-line');
        addLine('  my patterns                   - View your saved patterns', 'output-line');
        addLine('  share pattern                 - Share current pattern', 'output-line');
        addLine('  remix [pattern]               - Remix a shared pattern', 'output-line');
        addLine('  collab with [artist]          - Start collaboration', 'output-line');
        addLine('', 'output-line');
        addLine('ğŸ› ï¸ SYSTEM COMMANDS:', 'info-line');
        addLine('  clear                         - Clear terminal', 'output-line');
        addLine('  help                          - Show this help', 'output-line');
        addLine('', 'output-line');
        addLine('âœ… AI-powered music generation & identity system active!', 'success-line');
        return;
      }
      
      // Musical Identity Commands
      if (lowerCommand.includes('create musical identity') || lowerCommand === 'signup' || lowerCommand.includes('create account')) {
        if (musicalIdentityCreator) {
          musicalIdentityCreator.start();
          return;
        } else {
          addLine('âŒ Musical Identity Creator not available', 'error-line');
          return;
        }
      }
      
      if (lowerCommand === 'login') {
        addLine('ğŸµ Musical Identity Login:', 'success-line');
        addLine('ğŸ’¡ Try: "I\'m [your artist name]" or "login as [name]"', 'info-line');
        addLine('ğŸ¨ Or create a new identity with: "create musical identity"', 'output-line');
        return;
      }
      
      if (lowerCommand.includes('my profile') || lowerCommand.includes('profile')) {
        if (currentUser) {
          showUserProfile(currentUser);
        } else {
          addLine('âŒ Not logged in. Try "login" or "create musical identity"', 'error-line');
        }
        return;
      }
      
      if (lowerCommand === 'logout') {
        if (currentUser) {
          const artistName = currentUser.artistName;
          window.SimpleAuthSystem.logout();
          currentUser = null;
          addLine(`ğŸ‘‹ Goodbye, ${artistName}! Your musical identity is saved.`, 'success-line');
          addLine('ğŸ’¡ Use "login" or "create musical identity" to return', 'info-line');
        } else {
          addLine('âŒ You are not logged in', 'error-line');
        }
        return;
      }
      
      // Community Commands
      if (lowerCommand.includes('community feed') || lowerCommand === 'community') {
        if (communitySystem) {
          communitySystem.showCommunityFeed();
          return;
        }
      }
      
      if (lowerCommand.includes('find my tribe') || lowerCommand.includes('my tribe')) {
        if (communitySystem) {
          communitySystem.findMusicalTribe(currentUser);
          return;
        }
      }
      
      if (lowerCommand.includes('explore ')) {
        const genre = command.replace(/explore\s+/i, '').trim();
        if (communitySystem && genre) {
          communitySystem.exploreGenre(genre);
          return;
        }
      }
      
      if (lowerCommand.includes('trending patterns') || lowerCommand === 'trending') {
        if (communitySystem) {
          communitySystem.showTrendingPatterns();
          return;
        }
      }
      
      if (lowerCommand.includes('genre stats') || lowerCommand === 'stats') {
        if (communitySystem) {
          communitySystem.showGenreStats();
          return;
        }
      }
      
      // Pattern Sharing Commands
      if (lowerCommand.includes('browse patterns') || lowerCommand === 'browse') {
        if (patternSharingSystem) {
          const filter = lowerCommand.includes('recent') ? 'recent' : 
                        lowerCommand.includes('remixable') ? 'remixable' : 'popular';
          patternSharingSystem.browsePatterns(filter);
          return;
        }
      }
      
      if (lowerCommand === 'my patterns' || lowerCommand.includes('show my patterns')) {
        if (patternSharingSystem) {
          patternSharingSystem.showMyPatterns();
          return;
        }
      }
      
      if (lowerCommand.includes('share pattern') || lowerCommand === 'share') {
        if (patternSharingSystem && currentPattern) {
          const titleMatch = command.match(/share\s+(?:pattern\s+)?(?:as\s+)?["']?([^"']+)["']?/i);
          const title = titleMatch ? titleMatch[1].trim() : 'Untitled Pattern';
          patternSharingSystem.sharePattern(currentPattern, { title: title });
          return;
        } else if (!currentPattern) {
          addLine('âŒ No pattern to share. Create one first!', 'error-line');
          return;
        }
      }
      
      if (lowerCommand.includes('collab with ')) {
        const artist = command.replace(/collab(?:orate)?\s+with\s+/i, '').trim();
        if (patternSharingSystem && artist) {
          patternSharingSystem.startCollaboration(artist);
          return;
        }
      }
      
      if (lowerCommand.includes('save pattern')) {
        if (currentPattern) {
          const titleMatch = command.match(/save\s+(?:pattern\s+)?(?:as\s+)?["']?([^"']+)["']?/i);
          const title = titleMatch ? titleMatch[1].trim() : null;
          if (patternSharingSystem) {
            patternSharingSystem.savePattern(currentPattern, title);
          } else {
            savePattern(currentPattern); // Fallback to basic save
          }
          return;
        } else {
          addLine('âŒ No pattern to save. Create one first!', 'error-line');
          return;
        }
      }
      
      // Evolution Commands
      if (lowerCommand.includes('evolve') || lowerCommand.includes('evolution')) {
        handleEvolutionCommand(command);
        return;
      }
      
      if (lowerCommand.includes('mutate') || lowerCommand.includes('mutation')) {
        handleMutationCommand(command);
        return;
      }
      
      if (lowerCommand.includes('breed') && !lowerCommand.includes('breeding')) {
        handleBreedingCommand(command);
        return;
      }
      
      if (lowerCommand.includes('create') || lowerCommand.includes('make') || lowerCommand.includes('generate')) {
        generateMusic(command);
        return;
      }
      
      // Check if Musical Identity Creator is handling input
      if (musicalIdentityCreator && musicalIdentityCreator.isActive) {
        const handled = await musicalIdentityCreator.handleInput(command);
        if (handled) return;
      }
      
      // Try NLP processing for other commands
      if (nlp) {
        const result = nlp.processCommand(command);
        if (result.response) {
          addLine(result.response, 'info-line');
          return;
        }
      }
      
      // Easter eggs and fun commands
      if (lowerCommand === 'about' || lowerCommand === 'credits') {
        showAbout();
        return;
      }
      
      if (lowerCommand.includes('love') || lowerCommand === 'â¤ï¸' || lowerCommand === 'heart') {
        addLine('', 'output-line');
        addLine('â¤ï¸ Music is love, love is music!', 'highlight-line');
        addLine('ğŸµ Creating a special pattern just for you...', 'success-line');
        generateMusic('create a love song with dreamy vibes');
        return;
      }
      
      if (lowerCommand === 'party' || lowerCommand === 'ğŸ‰') {
        addLine('', 'output-line');
        addLine('ğŸ‰ PARTY MODE ACTIVATED!', 'highlight-line');
        addLine('ğŸ•º Let\'s get this party started!', 'success-line');
        generateMusic('create energetic party house music');
        return;
      }
      
      // Default response
      addLine('', 'output-line');
      addLine(`âœ… Command processed: "${command}"`, 'success-line');
      addLine('ğŸ’¡ Try: "create trap beat" or "make lo-fi music"', 'info-line');
      addLine('', 'output-line');
    }
    
    // Initialize when page loads
    document.addEventListener('DOMContentLoaded', function() {
      const terminalInput = document.getElementById('terminalInput');
      
      console.log('ğŸ“‹ Initializing terminal...');
      
      if (!terminalInput) {
        console.error('âŒ Terminal input not found');
        return;
      }
      
      // Initialize AI components
      try {
        // Initialize Nala AI (DeepSeek R1)
        nalaAI = new NalaAI();
        
        // Initialize supporting systems
        nlp = new NaturalLanguageProcessor();
        patternGenerator = new EnhancedPatternGenerator();
        
        // Set fallback generator for Nala AI
        nalaAI.setFallbackGenerator(patternGenerator);
        
        musicalIdentityCreator = new MusicalIdentityCreator({
          addLine: addLine,
          addHTML: addHTML,
          focusInput: () => terminalInput.focus()
        });
        communitySystem = new CommunitySystem({
          addLine: addLine,
          addHTML: addHTML,
          currentUser: () => currentUser
        });
        patternSharingSystem = new PatternSharingSystem({
          addLine: addLine,
          addHTML: addHTML,
          currentUser: () => currentUser,
          playPattern: playPattern
        });
        window.patternSharingSystem = patternSharingSystem; // Make globally accessible
        
        // Initialize Jam System
        window.jamUI = new JamTerminalUI({
          terminal: document.getElementById('terminal-output'),
          addLine: addLine,
          addHTML: addHTML
        });
        
        // Initialize Breeding System
        window.breedingUI = new BreedingTerminalUI({
          addLine: addLine,
          addHTML: addHTML,
          playPattern: playPattern
        });
        
        // Initialize Voice Input System
        window.voiceUI = new VoiceTerminalUI({
          addLine: addLine,
          addHTML: addHTML,
          playPattern: playPattern
        });
        
        // Initialize Evolution Systems
        if (window.PatternEvolutionEngine) {
          evolutionEngine = new PatternEvolutionEngine();
          console.log('ğŸ§¬ Pattern Evolution Engine initialized');
        }
        
        if (window.DNAMutationSystem) {
          mutationSystem = new DNAMutationSystem();
          console.log('ğŸ§¬ DNA Mutation System initialized');
        }
        
        if (window.CrossPatternBreedingSystem) {
          breedingSystem = new CrossPatternBreedingSystem();
          console.log('ğŸ§¬ Cross-Pattern Breeding System initialized');
        }
        
        // Check AI health
        nalaAI.checkHealth().then(health => {
          console.log('ğŸ¤– Nala AI Health:', health);
          if (health.status === 'ok') {
            addLine('ğŸ¤– Nala AI (DeepSeek R1) online & ready', 'system-line');
          } else {
            addLine('ğŸ¤– Nala AI offline - using fallback generation', 'info-line');
          }
        });
        
        // Check Phase 3 AI Ensemble System availability
        console.log('ğŸ” Checking Phase 3 components:', {
          Phase3IntegrationEngine: !!window.Phase3IntegrationEngine,
          AIEnsembleConductor: !!window.AIEnsembleConductor,
          RhythmistAI: !!window.RhythmistAI,
          MelodistAI: !!window.MelodistAI,
          HarmonistAI: !!window.HarmonistAI
        });
        
        if (window.Phase3IntegrationEngine && window.AIEnsembleConductor) {
          addLine('ğŸ¼ Phase 3 AI Ensemble System: Multi-agent collaboration ready', 'success-line');
          addLine('ğŸ­ 10 specialized AI agents active for creative collaboration', 'success-line');
          console.log('âœ… Phase 3 AI Ensemble System activated');
        } else if (window.Phase2IntegrationEngine && window.PatternDNAEngine && window.ContextAwareEngine && window.AdvancedPersonalizationEngine) {
          addLine('ğŸ§¬ Phase 2 Advanced AI System: Multi-dimensional Pattern DNA ready', 'success-line');
          addLine('ğŸ¨ Context-aware generation and advanced personalization active', 'success-line');
          console.log('âš ï¸ Phase 3 unavailable, using Phase 2');
        } else if (window.ProceduralPatternGenerator && window.SemanticAnalysisEngine && window.UniquenessEngine) {
          addLine('ğŸ¤– Phase 1 Procedural AI System ready', 'success-line');
          console.log('âš ï¸ Advanced AI unavailable, using Phase 1');
        } else {
          addLine('ğŸ”„ Enhanced fallback generation system ready', 'info-line');
          console.log('âš ï¸ Advanced AI unavailable, using fallback');
        }
        
        addLine('ğŸ§  AI music generation & community system initialized', 'system-line');
        addLine('ğŸ¸ Live jam rooms ready - type "jam help" to get started', 'system-line');
        addLine('ğŸ§¬ Pattern breeding ready - type "breed" to see commands', 'system-line');
        addLine('ğŸ¤ Voice input ready - type "hum" to sing a melody', 'system-line');
        
        // Evolution system status
        if (evolutionEngine && mutationSystem && breedingSystem) {
          addLine('ğŸ§¬ Advanced Pattern Evolution: Genetic algorithms active', 'success-line');
          addLine('ğŸ”¬ DNA Mutation & Cross-breeding systems online', 'success-line');
        }
      } catch (error) {
        console.error('AI initialization error:', error);
        addLine('âš ï¸ AI system loading... some features may be limited', 'info-line');
      }
      
      // Add Enter key handler
      terminalInput.addEventListener('keydown', function(event) {
        if (event.key === 'Enter') {
          event.preventDefault();
          const command = terminalInput.value.trim();
          
          if (command) {
            executeCommand(command).catch(error => {
              console.error('Command execution error:', error);
              addLine('âŒ Command execution error', 'error-line');
            });
            terminalInput.value = '';
          }
        }
      });
      
      // Focus the input
      terminalInput.focus();
      
      // Check for existing user session
      const existingUser = window.SimpleAuthSystem?.getCurrentUser();
      if (existingUser) {
        currentUser = existingUser;
        addLine(`ğŸµ Welcome back, ${existingUser.artistName}!`, 'success-line');
        addLine('ğŸ’¡ Your musical identity has been restored', 'info-line');
      }
      
      console.log('âœ… Terminal ready!');
      addLine('ğŸ¯ Terminal loaded with AI music generation', 'system-line');
      if (currentUser) {
        addLine('âŒ¨ï¸ Try "create new pattern" or "my profile"!', 'info-line');
      } else {
        addLine('âŒ¨ï¸ Try "create musical identity" or "create trap beat"!', 'info-line');
      }
    });
    
    // Register service worker for PWA features
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js', { scope: '/' })
          .then(registration => {
            console.log('SW registered: ', registration);
          })
          .catch(registrationError => {
            console.log('SW registration failed: ', registrationError);
          });
      });
    }
  </script>
  <script src="js/ascii-visualizer.js?v=2.0"></script>
  <script src="js/live-jam-rooms.js?v=2.0"></script>
  <script src="js/jam-terminal-ui.js?v=2.0"></script>
  <script src="js/pattern-breeding.js?v=2.0"></script>
  <script src="js/breeding-terminal-ui.js?v=2.0"></script>
  <script src="js/voice-input.js?v=2.0"></script>
  <script src="js/voice-terminal-ui.js?v=2.0"></script>
  <script>
    // Initialize ASCII Visualizer
    const visualizer = new ASCIIVisualizer();
    let visualizerContainer = null;
    
    // Add visualizer commands
    const originalProcessCommand = processCommand;
    processCommand = async function(command) {
      const lowerCommand = command.toLowerCase().trim();
      
      // Jam commands
      if (window.jamUI) {
        const isJamCommand = await window.jamUI.processCommand(command);
        if (isJamCommand) return;
      }
      
      // Breeding commands
      if (window.breedingUI) {
        const isBreedingCommand = window.breedingUI.processCommand(command);
        if (isBreedingCommand) return;
      }
      
      // Voice commands
      if (window.voiceUI) {
        const isVoiceCommand = window.voiceUI.processCommand(command);
        if (isVoiceCommand) return;
      }
      
      // Visualizer commands
      if (lowerCommand.startsWith('viz ') || lowerCommand.startsWith('visualizer ')) {
        const vizCommand = lowerCommand.replace(/^(viz|visualizer)\s+/, '');
        
        switch (vizCommand) {
          case 'on':
          case 'start':
            startVisualizer();
            return;
            
          case 'off':
          case 'stop':
            stopVisualizer();
            return;
            
          case 'spectrum':
          case 'waveform':
          case 'matrix':
          case 'particles':
            if (visualizer.isActive) {
              visualizer.setMode(vizCommand);
              addLine(`ğŸ¨ Visualizer mode: ${vizCommand}`, 'success-line');
            } else {
              addLine('âŒ Start visualizer first with "viz on"', 'error-line');
            }
            return;
            
          case 'help':
            addLine('', 'output-line');
            addLine('ğŸ¨ ASCII Visualizer Commands:', 'info-line');
            addLine('  viz on/start     - Start visualizer', 'output-line');
            addLine('  viz off/stop     - Stop visualizer', 'output-line');
            addLine('  viz spectrum     - Frequency spectrum bars', 'output-line');
            addLine('  viz waveform     - Audio waveform', 'output-line');
            addLine('  viz matrix       - Matrix rain effect', 'output-line');
            addLine('  viz particles    - Particle system', 'output-line');
            addLine('', 'output-line');
            return;
        }
      }
      
      // Call original command processor
      return originalProcessCommand.call(this, command);
    };
    
    function startVisualizer() {
      if (visualizerContainer) {
        addLine('ğŸ¨ Visualizer already running', 'info-line');
        return;
      }
      
      // Create visualizer container
      visualizerContainer = document.createElement('div');
      visualizerContainer.id = 'ascii-visualizer';
      visualizerContainer.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        border: 2px solid #00ff00;
        padding: 20px;
        font-family: monospace;
        font-size: 12px;
        line-height: 1;
        color: #00ff00;
        z-index: 1000;
        white-space: pre;
        cursor: pointer;
        box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
      `;
      
      visualizerContainer.innerHTML = '<div>ğŸµ Click on a playing pattern to visualize...</div>';
      document.body.appendChild(visualizerContainer);
      
      // Listen for visualizations
      window.addEventListener('asciiVisualization', handleVisualization);
      
      // Make it draggable
      let isDragging = false;
      let dragOffset = { x: 0, y: 0 };
      
      visualizerContainer.addEventListener('mousedown', (e) => {
        isDragging = true;
        dragOffset.x = e.clientX - visualizerContainer.offsetLeft;
        dragOffset.y = e.clientY - visualizerContainer.offsetTop;
      });
      
      document.addEventListener('mousemove', (e) => {
        if (isDragging) {
          visualizerContainer.style.left = e.clientX - dragOffset.x + 'px';
          visualizerContainer.style.top = e.clientY - dragOffset.y + 'px';
          visualizerContainer.style.transform = 'none';
        }
      });
      
      document.addEventListener('mouseup', () => {
        isDragging = false;
      });
      
      // Double-click to close
      visualizerContainer.addEventListener('dblclick', stopVisualizer);
      
      addLine('ğŸ¨ ASCII Visualizer started (double-click to close)', 'success-line');
      addLine('ğŸ’¡ Try: "viz spectrum", "viz matrix", "viz particles"', 'info-line');
    }
    
    function stopVisualizer() {
      if (visualizerContainer) {
        visualizerContainer.remove();
        visualizerContainer = null;
        window.removeEventListener('asciiVisualization', handleVisualization);
        visualizer.stop();
        addLine('ğŸ¨ Visualizer stopped', 'info-line');
      }
    }
    
    function handleVisualization(event) {
      if (visualizerContainer) {
        const { visualization, colorScheme } = event.detail;
        visualizerContainer.innerHTML = `<div style="color: ${colorScheme.mid}">${visualization}</div>`;
      }
    }
    
    // Hook into audio playback
    const originalPlayAudio = window.playAudio;
    if (originalPlayAudio) {
      window.playAudio = function(audioBuffer, button) {
        const result = originalPlayAudio.call(this, audioBuffer, button);
        
        // Connect visualizer to audio context if active
        if (visualizer.isActive && window.audioContext) {
          visualizer.connectToAudioContext(window.audioContext, window.audioSource);
        }
        
        return result;
      };
    }
  </script>
</body>
</html>